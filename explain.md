## Test 1
- spec
    - vuser: 100
    - duration: 30s
    - timeout: 8s
    - vuser's api request: every 0.5 seconds
    - query call delay time: 1s
- explain
    - (체크 필요) 아마 점직적으로 요청 빈도를 높인 것 같음. 요청 횟수는 400~500 사이로 발생함.
    - DB 단에서 의도적으로 쿼리를 delay하면서 DB단 병목 발생시킴.
    - 프로젝트 별 성능 비교 
      - TODO 작성 예정: 요청 처리 시간, 성공률, 네트워크 접속 시간(blocking으로 인한 이벤트 루프 delay?, 원인 파악 필요) 
      - mvc-api(webmvc + controller + jpa)
      - corouter-api(webflux + coRouter + jpa)
      - webflux-blocking-api(webflux + reactive + jpa)
      - webflux-non-blocking-api(webflux + reactive + r2dbc)

## Test 1.1

이건 따로 기록은 안해둬서 그냥 말로만 적는건데, DB connection thread pool을 넉넉하게 가져가면 mvc든 webflux든 모든 모듈에서 100% 성공률을 보여줌.
즉, DB에 병목이 없는 상태에서는 전부 효율적이라고 볼 수 있을까?

## Test 2

- mvc에는 `Thread.sleep()`, coRouter에는 `delay()` 를 500ms를 줘서 DB단 I/O blocking 뿐만 아니라 연산 시간을 추가로 가정
  - (의문) 
    - 이렇게 처리하면 코루틴은 suspend 사용하니까 더 좋게 처리되는거 아닌가? 그렇다고 CPU에 부하를 주자니 그것도 좀 이상함. 실제 서비스는 CPU bound가 적을 것 같은데
  - 주요 비교 대상인 mvc-api와 corouter-api 모듈만 수행했는데, corouter-api가 더 높은 처리량을 보여주긴 함. 그래도 둘 다 70% 이상의 실패율을 보여줌(=처리량이 떨어짐)

## Test 3

DB 병목을 줄이고, 서버의 연산이 오래 걸린다고 가정함. 쿼리 딜레이를 1초 -> 0.1초로 줄이고, 각 요청에서 1초씩 쓰레드나 코루틴을 대기함.

- 이번에도 mvc-api와 corouter-api 모듈만 테스트했는데, corouter-api는 모든 요청을 처리했다.
  - 근데 이게 올바른 비교인지는 모르겠는게, CPU 연산을 수행하는게 아니라, 그냥 해당 코루틴을 delay 시켰기 때문이다.
  - 근데 또 메모리나 CPU 병목이 생기지 않는 한 큰 문제는 아닌거 같기도 하고... 어차피 요청을 반환하는 시간은 delay로 같으니까.
    - 근데 서버의 연산 수행 대신 계속 요청을 받거나 코루틴을 관리하면서 더 속도가 빠른 건 맞을것 같음.

## Test 4

루프를 사용해서 의미없는 연산을 0.5초동안 계속 수행하게 함. (내부에서 계속 수를 더하고, API 결과로 반환하게 해서 컴파일 최적화로 제거되는 여지를 줄임.)

- 이번에도 mvc-api와 corouter-api 모듈만 테스트했고, 오히려 corouter-api 성능이 낮았다.
  - 예상과 다른 이상한 결과가 나왔는데, mvc-api는 모든 요청을 처리했지만,corouter-api는 25% 정도의 요청을 처리하지 못했다.
  - 가정
    - 예시가 잘못되었다. 구현 방법 등...
    - blocking 방식이므로 netty가 의도한 기본 설정과 다르게 튜닝이 필요하다.
    - 사실은 corouter-api 처럼 사용하는 방식이 비효율적이다.
    - (+ netty같은 이벤트 루프 방식은 기존 방식 대비 io bound에 효율적이고 cpu bound는 비효율적이라는 소리를 들은 것 같은데 이게 원인일까?)

## Test 5

- DB단의 병목이 끼면 성능이 똑같다는건 확인함. 앞 단에서 더 효율적인 처리가 가능하다면, 병목이 없는(=DB 접근이 없는) API가 섞인다면 더 높은 처리율을 보일 것 같음.
  - 이건 가정을 검증하기 위한 거지, 아마 실제로는 이런 DB에 접근하지 않는 API 자체가 없으니까 
  - 이게 만약 성공한다면, corouter-api는 쓰레드 풀의 제한을 넘어서 요청을 받을 수 있는(= 앞단의 병목이 더 적은) 형태라고 보면 좋을듯.
  - db call이 있는 요청 후 0.5 딜레이, 없는 요청 후 0.5초 딜레이를 반복. 그 외 조건은 Test1 과 동일한 상태로 작성.
- 결과
  - ~~corouter-api가 더 많이 실패했는데, netty의 메모리? 과한 요청으로 인해서 바로 실패하고 있었다.~~
    - 이거 착각한거임. 지금 수치는 잘 되는거 맞음. 저번에 200명+1분인가 했을 때 생긴 문제 
  - 따라서 적절한 테스트를 위해서는 DB단의 병목이 발생하면서 과하지 않는 요청이 들어오도록 k6의 스크립트를 가공해야 한다.
  - 왜냐면 지금 상황의 결과는 테스트를 수행하기 위해 적절한 조건이 아니니까... (요청을 못 받고 바로 던지는 상태, 너무 과한 요청이 들어오는 상태라고 볼 수 있음.)
    - 테스트 목적은 앞 단의 병목을 처리하는데 corouter-api이 더 효율적인지 검증하는 것이기 때문. (=mvc는 스레드 풀이 부족하지만, corouter-api는 스레드 풀 제한 없이 받을 수 있음?을 확인하는거)

## 걍 메모

- 어차피 이거 올리기에는 너무 삽질을 많이해서 걍 버려야 할듯
- 근데 timeout 조건 제거하고, 처리 시간 로깅 추가하고 하니까. 처리 시간이 corouter-api가 mvc보다 조금 더 더 효율적임.
- 로그를 보면 mvc는 미리 쓰레드 풀만큼 다 받아놓고 처리한다면, netty는 처리되면 그떄그떄 받아서 처리하는데, 그래서 로그의 duration이 더 높게 나옴.
  - 근데 요청자 입장에서 보면 대기 시간은 마찬가지 아닌가? 오히려 netty가 요청을 더 많이 빨리 받아놔서 timeout으로 실패하는줄 알았는데,
  - 아마 netty가 요청은 먼저 받고, 처리는 반환되어야 하는 듯?
  - 그 근거로 처리 속도를 보면 corouter-api는 요청을 받고 처리하기까지 mvc-api에 비해 높은 변동성을 가짐. 최악은 13초 - 36초로 거의 3배차이 (p90는 1.5, p95는 2배). 따라서 mvc보다 더 많이 받을 수는 있음.
  - 근데? 이게 DB 병목이 있으면 처리 평균 속도는 결국 비슷함. 
- 그래서 Test 4 처럼 DB Call이 없는걸 추가해서 테스트해봄.
  - 근데 이러니까 corouter-api가 오히려 더 느리고 처리율도 낮은데?
  - 그게 맞나? 요청을 미리 받는거니까? 
    - 아니여야 하지 않나? 오히려 blocking이 없으니까 요청을 더 많이 처리해야 하는거 아닌가?
    - 아무리 생각해봐도 이게 더 효율적인 구조라는걸 이해할수가 없는데, 애초에 non-blocking(recator)에서 blocking이 들어가면 더 느려지는건 당연한거 아니였던가?
    - 이게 어떻게 더 효율적이라는거지?
    - 검증이라도 되면 몰라...... 아니면 내가 잘못하고 있는건가?
    - 이쯤 되면 의심될 정도인게, 효율적이면 다른 곳에서도 어떻게든 찾아서 쓰지 않았을까? 이러면 이게 더 좋은 거라고 어떻게 확신할 수 있지?
  - 혹시 몰라서 DB 병목이 거의 적게 0.1초로 테스트
    - db call 있는거, 없는거 번갈아서 호출
      - http_req_duration(corouter-api): avg=154.5ms  min=161µs med=112.09ms max=1.67s   p(90)=272.19ms p(95)=346.42ms
      - http_req_duration(mvc-api): avg=77.94ms  min=174µs med=96.59ms max=1.51s   p(90)=125.4ms  p(95)=149.67ms
    - db call만 호출하는거
      - http_req_duration(corouter-api): avg=585.12ms min=139.62ms med=580.39ms max=1.98s   p(90)=601.46ms p(95)=620.71ms 
      - http_req_duration(mvc-api): avg=582.22ms min=103.98ms med=575.31ms max=1.27s   p(90)=594.75ms p(95)=603.82ms
      - 어느 부분으로 봐도 더 빠른 경우가 없는데?
      - 뭐가 문제일까?
      - 일단 이걸로 거의 몇 주째 틈틈히 확인하고 있어도, 더 효율적이라는것 모르겠으니까... 콜라한테 물어보던가 하고, 일단은 그만 찾기. 이제는 시간낭비야...
